{
  "hash": "c13f5fe962bdd4973f5114d3367e9a6e",
  "result": {
    "markdown": "---\ntitle: \"Using Machine Learning for Ocean Chemistry Prediction\"\ndescription: Training machine learning models to predict dissolved inorganic carbon in water samples.\n\neditor: visual\nauthor:\n  - name: Kiran Favre\n    url: https://kiranfavre.github.io\n    affiliation: Master of Environmental Data Science\n    affiliation-url: https://ucsb-meds.github.io/\ndate: 03-21-2023\ncitation: \n  url: https://kiranfavre.github.io/posts/2023-03-21_ml_predictions/ \ncategories: [Machine Learning, R, Ocean Chemistry]\nformat:\n  html:\n    code-fold: true\n    code-summary: \"Show code\"\n---\n\n\n## Background\n\nFor our final project in my machine learning course, we participated in a Kaggle competition to predict the concentration of dissolved inorganic carbon in water samples by using ocean chemistry data. This data comes from the California Cooperative Oceanic Fisheries Investigations (CalCOFI) program.\n\n## Objective\n\nTo predict dissolved inorganic carbon, we will be using a Linear Regression Model in R to make these predictions. We will use the CalCOFI data to train our model to make predictions of inorganic dissolved carbon concentrations in different parts of the ocean that aren't included in the training data.\n\nThe variables we are using as predictors in our model are:\n\n-   NO2uM - Micromoles of Nitrite per liter of seawater\n\n-   NO3uM - Micromoles of Nitrate per liter of seawater\n\n-   NH3uM - Micromoles of Ammonia per liter of seawater\n\n-   R_TEMP - Reported (Potential) Temperature (degrees Celsius)\n\n-   R_Depth - Reported Depth from pressure (meters)\n\n-   R_Sal - Reported Salinity (from Specific Volume Anomoly, M³ per Kg)\n\n-   R_DYNHT - Reported Dynamic Height (work per unit mass)\n\n-   R_Nuts - Reported Ammonium concentration (micromoles per Liter)\n\n-   R_Oxy_micromol.Kg - Reported Oxygen concentration (micromoles per kilogram)\n\n-   PO4uM - Micromoles of Phosphate per liter of seawater\n\n-   SiO3uM - Micromoles of Silicate per liter of seawater\n\n-   TA1 - Total Alkalinity (micromoles per kilogram solution)\n\n-   Salinity1 - Salinity (Practical Salinity Scale 1978)\n\n-   Temperature_degC - Temperature (degrees Celsius)\n\n## Load and split data\n\nTo train machine learning models using a data set, the model must have training data to learn from and test data to compare its predictions to to evaluate model performance. We will then split the training data further into two groups, a validation set and training set. The training set will still be used to train the model, while the validation set will be used to evaluate how well the model performed.\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n#Reading in data used to train model\ntraining_data <- read_csv(here(\"posts\",\n                               \"2023-03-21_calcofi_ml\",\n                               \"data\",\n                               \"train.csv\")) %>%\n  clean_names() %>%\n  select(-x13) #remove this since its all NA\n\n#Reading in data that will be used to test model\ntesting_data <- read_csv(here(\"posts\",\n                               \"2023-03-21_calcofi_ml\",\n                               \"data\",\n                               \"test.csv\")) %>%\n  clean_names() %>% \n  mutate(ta1_x = ta1)\n\n\n#split the training data into training and evaluation sets, stratify by dissolved inorganic carbon concentration\ndata_split <- initial_split(training_data,\n                            strata = dic)\n\n#extract training and test data from the training data\ntraining_set <- training(data_split)\nevaluation_set <- testing(data_split)\n\n#take a look at training and testing data \nhead(training_data)\nhead(evaluation_set)\n```\n:::\n\n\n## Pre-Processing Data, Creating Recipe, Creating Models, and Creating Workflow\n\nTo pre-process the data for our model, we begin by creating a recipe where dissolved inorganic carbon concentration is the predicted value and all the variables mentioned above as the predictors. \n\n::: {.cell}\n\n```{.r .cell-code}\n#set seed for reproducibility\nset.seed(711)\n\n#creating a recipe\nbottle_recipe <- recipe(dic ~.,\n                        data = training_set) %>% \n  step_dummy(all_nominal(),\n             -all_outcomes(),\n             one_hot = TRUE) %>% \n  step_normalize(all_numeric(),\n                 -all_outcomes()) %>% \n  prep()\n\n#creating model specification of linear regression\nbottle_model <- linear_reg() %>% \n  set_engine(\"lm\") %>% \n  set_mode(\"regression\")\n\n#bundle recipe and model spec into a workflow\nbottle_wf <- workflow() %>% \n  add_recipe(bottle_recipe) %>% \n  add_model(bottle_model)\n```\n:::\n\n\n## Fit Model to Training Data and Make Predictions\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#creating and training a model on the training data\nfit_bottle <- bottle_wf %>%\n  fit(training_set)\n\n#using the model to make predictions on the validation data   \nbottle_results <- fit_bottle %>% \n  predict(evaluation_set) %>%\n  bind_cols(evaluation_set) %>% \n  mutate(dic_prediction = .pred_res) %>% \n  relocate(dic,\n           .before = id) %>% \n  relocate(dic_prediction,\n           .before = id) %>% \n  select(-.pred_res)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in predict.lm(object = object$fit, newdata = new_data, type =\n\"response\"): prediction from rank-deficient fit; attr(*, \"non-estim\") has\ndoubtful cases\n```\n:::\n\n```{.r .cell-code}\n#retrieve and evaluate our predictions\nbottle_metrics <- bottle_results %>%\n  metrics(estimate = dic_prediction,\n          truth = dic)\n\nbottle_metrics\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 3\n  .metric .estimator .estimate\n  <chr>   <chr>          <dbl>\n1 rmse    standard       6.82 \n2 rsq     standard       0.996\n3 mae     standard       3.45 \n```\n:::\n:::\n\n\n## Test Model\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Outputting predictions for our testing data\ntest_data_predictions <- fit_bottle %>% \n  predict(testing_data) %>%\n  bind_cols(testing_data) %>% \n  mutate(DIC = .pred_res) %>% \n  relocate(DIC,\n           .before = id) %>% \n  select(id,\n         DIC)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in predict.lm(object = object$fit, newdata = new_data, type =\n\"response\"): prediction from rank-deficient fit; attr(*, \"non-estim\") has\ndoubtful cases\n```\n:::\n\n```{.r .cell-code}\ntest_data_predictions\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 485 × 2\n      id   DIC\n   <dbl> <dbl>\n 1  1455 2173.\n 2  1456 2194.\n 3  1457 2325.\n 4  1458 1993.\n 5  1459 2147.\n 6  1460 2036.\n 7  1461 2159.\n 8  1462 2196.\n 9  1463 2270.\n10  1464 2314.\n# ℹ 475 more rows\n```\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}